// Never inc. App Architecture (Supabase + Firebase) .cursorrules

// Flexibility Notice
// Note: This is the current project structure. Follow these patterns to maintain consistency.
// Focus on maintaining the existing architecture while applying Flutter best practices.

// Architecture Overview
const architectureOverview = [
"Feature-first architecture with Riverpod state management",
"Hooks-based widget composition",
"SharedPreferences and Sembast for local persistence",
"Supabase for backend services",
"Firebase for analytics and messaging",
"Static analysis with pedantic_mono",
];

// Project Structure
const projectStructure = `lib/
  core/
    ad_mob/           // AdMob関連の実装
    constants/        // アプリ全体で使用する定数
    extensions/       // 拡張メソッド
    gen/             // 自動生成されたコード
    providers/       // 共通のProviders
      firebase_messaging/
      supabase/
    res/             // リソース（色、スタイルなど）
    utils/           // ユーティリティ関数
    widgets/         // 共通Widget
  features/          // 機能単位のモジュール
    feature_name/    // 各機能のディレクトリ
      providers/     // 機能固有のProviders
      widgets/       // 機能固有のWidget
      {feature}_page.dart  // メインページ
test/
  unit/
  widget/`;

// State Management Guidelines
const stateManagementGuidelines = `

1. Use Riverpod with @riverpod annotation
2. Let riverpod_generator determine the appropriate Notifier class
3. Use appropriate local storage:
   - SharedPreferences for simple settings and flags
   - Sembast for complex user data and content
4. Follow proper state immutability patterns
5. Use proper provider scoping
6. Ensure code passes static analysis:
   - Follow pedantic_mono lint rules
   - Fix all analysis warnings
   - Use proper null safety patterns
   - Add required documentation comments
     `;

// Widget Guidelines
const widgetGuidelines = `

1. Use HookConsumerWidget for stateful widgets
2. Implement proper error handling with adaptive_dialog
3. Use proper widget composition
4. Follow Material 3 design principles
5. Implement proper loading states
6. Follow navigation patterns:
   - Implement static show() method for page transitions
   - Use Navigator.push with CupertinoPageRoute for standard transitions
   - Use page_transition for custom transition effects when needed
   - Set proper route settings with routeName
     `;

// Provider Guidelines
const providerGuidelines = `

1. Place providers in feature/providers directory
2. Use proper provider dependencies
3. Implement proper error handling
4. Follow proper caching strategies
5. Use proper provider scoping
6. Follow single responsibility principle:
   - One provider should manage one specific state
   - State mutations should be handled by a single source of truth
   - Keep business logic focused and cohesive
     `;

// Feature Organization
const featureGuidelines = `

1. Organize by feature first
2. Keep features independent
3. Share common code through core
4. Follow consistent naming patterns
5. Implement proper routing
6. Follow DRY principle:
   - Extract common widgets to core/widgets
   - Share common providers through core/providers
   - Use extensions for repeated code patterns
   - Create utility functions for common operations
     `;

// Testing Guidelines
const testingGuidelines = `

1. Write offline unit tests:
   - Use mockito for mocking dependencies
   - Minimize network and database dependencies
   - Focus on testing business logic in isolation
2. Implement widget tests for complex UI
3. Use proper mocking strategies
4. Follow proper test naming conventions
   `;

// Performance Guidelines
const performanceGuidelines = `

1. Implement proper image caching
2. Optimize list views for UGC:
   - Use ListView.builder for lazy loading
   - Implement pagination for large datasets
   - Cache list items appropriately
   - Handle loading and error states
   - Use proper scroll performance optimization
3. Follow proper state management patterns
4. Implement proper memory management
5. Use proper ad loading strategies
   `;

// Naming Guidelines
const namingGuidelines = `

1. Follow consistent casing:

   - Directory names: snake_case
   - File names: snake_case
   - Class names: UpperCamelCase
   - Variable names: camelCase
   - Constant names: camelCase

2. Screen and Component naming:

   - Pages: NounPage (e.g., ArticlePage, ArticlesPage)
   - Components: NounComponentType (e.g., ArticleTile, ArticleCard)
   - Avoid generic Widget suffix (e.g., ArticleWidget)

3. Data class naming:

   - Basic: Noun (e.g., Article)
   - Modified: AdjectiveNoun or NounNoun (e.g., LatestArticle, PrivateArticle)

4. Data source layer naming:

   - API clients: NounClient (e.g., GitHubClient)
   - Repositories: NounRepository (e.g., ArticleRepository)
   - Data sources: NounDataSource (e.g., ArticleDataSource)

5. General principles:
   - Use nouns or adjectives for entities
   - Use verbs for actions
   - Consider pluralization in naming
   - Keep names clear and descriptive
     `;
